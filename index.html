<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Story Tag — Two-Player Word Game</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    body { margin: 0; background:#0f1220; color:#f5f7ff; display:flex; min-height:100vh; }
    .wrap { margin:auto; width:min(900px, 92vw); padding:24px; }
    .card { background:#171a2b; border:1px solid #2a2f4a; border-radius:14px; padding:20px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    h1 { margin:0 0 6px; font-size: clamp(24px, 4vw, 34px); letter-spacing:.3px; }
    p.sub { margin:0 0 18px; color:#b9c0ff; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    label { font-size:14px; color:#b9c0ff; }
    input[type="text"], input[type="password"] { width:100%; padding:12px 14px; border-radius:10px; border:1px solid #303659; background:#0f1328; color:#fff; }
    input[type="text"]::placeholder, input[type="password"]::placeholder { color:#8890b3; }
    input[disabled] { opacity:.6; }
    button { padding:12px 16px; border-radius:10px; border:1px solid #39406a; background:#2a2f4a; color:#fff; cursor:pointer; transition:.15s transform ease; }
    button:hover { transform: translateY(-1px); }
    button:disabled { opacity:.55; cursor:not-allowed; transform:none; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hint { font-size:13px; color:#9aa3d7; }
    .ok { color:#69f0ae; }
    .err { color:#ff6b6b; }
    .warn { color:#ffd166; }
    .story { background:#0c0f22; border:1px solid #2a2f4a; border-radius:12px; padding:14px; min-height:100px; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
    .pill { padding:6px 10px; border-radius:999px; background:#1c2142; border:1px solid #2a2f4a; color:#c6cdff; font-size:12px; display:flex; align-items:center; gap:8px; }
    .muted { color:#9aa3d7; font-size:14px; }
    .spacer { height:10px; }
    .turn { font-weight:600; }
    .nameTag { font-weight:700; }
    .small { font-size:12px; color:#9aa3d7; }
    .divider { height:1px; background:#2a2f4a; margin:14px 0; }
    .tag { display:inline-flex; align-items:center; gap:6px; }
    .dot { width:8px; height:8px; border-radius:50%; background:#666; box-shadow: 0 0 0 1px rgba(255,255,255,.12) inset; }
    .word { display:inline; }
    .word + .word::before { content: " "; }
    .colourWrap { position: relative; display: inline-block; }
    .swatch{ width:28px; height:14px; border-radius:7px; border:1px solid #2a2f4a; background:#58a6ff; display:inline-block; vertical-align:middle; box-shadow: inset 0 0 0 1px rgba(0,0,0,.25); }
    .swatchInput{ position:absolute; inset:0; opacity:0; cursor:pointer; }
    a.link { color:#a6b3ff; text-decoration:none; cursor:pointer; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Story Tag</h1>
      <p class="sub">Create a private session with an ID + password, then share both with a friend. Take turns adding one word to build a story.</p>

      <div id="auth" class="grid">
        <div>
          <label for="name">Your name</label>
          <input id="name" type="text" maxlength="24" placeholder="e.g., Alex" />
        </div>
        <div>
          <label for="sessionId">Session ID</label>
          <input id="sessionId" type="text" maxlength="32" placeholder="e.g., 343w4 (friendly name)" />
          <div class="small hint">This is a friendly label. Privacy comes from the password-derived key.</div>
        </div>
        <div>
          <label for="password">Password</label>
          <input id="password" type="password" maxlength="64" placeholder="Required once unless remembered" />
          <div class="small hint" id="savedHint"></div>
        </div>
        <div class="row">
          <label class="small"><input id="rememberChk" type="checkbox" /> Remember this session on this device</label>
        </div>
        <div class="row">
          <button id="createBtn">Create session</button>
          <button id="joinBtn">Join session</button>
          <div id="joinStatus" class="small"></div>
        </div>
      </div>

      <div id="game" style="display:none">
        <div class="row">
          <div class="pill">Session: <span id="sessionLabel"></span></div>
          <div class="pill">You:
            <span class="tag"><span id="youDot" class="dot"></span><span id="youLabel" class="nameTag"></span></span>
          </div>
          <div class="pill">Partner:
            <span class="tag"><span id="peerDot" class="dot"></span><span id="peerLabel"></span></span>
          </div>
          <div class="pill">Words: <span id="wordCount">0</span></div>
          <div class="pill">Status: <span id="statusDot">Waiting…</span></div>
          <div class="pill">
            Colour:
            <span class="colourWrap">
              <span id="colourSwatch" class="swatch" title="Pick your colour"></span>
              <input id="colourPicker" type="color" class="swatchInput" value="#58a6ff" />
            </span>
          </div>
        </div>

        <div class="divider"></div>

        <div class="story" id="storyBox" aria-live="polite">(No words yet—be the first to write!)</div>
        <div class="spacer"></div>

        <div id="turnBanner" class="muted">Waiting for partner…</div>
        <div class="spacer"></div>

        <div class="row">
          <input id="wordInput" type="text" placeholder="Your word…" autocomplete="off" />
          <button id="submitBtn">Add Word</button>
        </div>
        <div class="hint">Rules: one word per turn. Letters, apostrophes, hyphens, and optional punctuation at the end (. , ! ?) allowed.</div>

        <div class="divider"></div>

        <div class="toolbar">
          <button id="copyBtn">Copy story</button>
          <button id="downloadBtn">Download .txt</button>
          <button id="leaveBtn">Leave session</button>
        </div>
        <div id="errorBox" class="small err"></div>
      </div>
    </div>
  </div>

  <!-- Firebase via CDN -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, get, set, update, onValue, serverTimestamp,
      onDisconnect, remove
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDf-zLudeu9OUiDVj984bDCtoZ-ehs_uD0",
      authDomain: "zetabun-91b0c.firebaseapp.com",
      databaseURL: "https://zetabun-91b0c-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "zetabun-91b0c",
      storageBucket: "zetabun-91b0c.firebasestorage.app",
      messagingSenderId: "594713569270",
      appId: "1:594713569270:web:fa1d230bd5fd1ce28549d7",
      measurementId: "G-SQR25FYPLC"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Elements
    const $ = id => document.getElementById(id);
    const createBtn = $("createBtn"), joinBtn = $("joinBtn"), joinStatus = $("joinStatus"),
          auth = $("auth"), game = $("game"),
          nameInput = $("name"), sessionInput = $("sessionId"), passwordInput = $("password"),
          rememberChk = $("rememberChk"), savedHint = $("savedHint"),
          sessionLabel = $("sessionLabel"),
          youLabel = $("youLabel"), peerLabel = $("peerLabel"),
          youDot = $("youDot"), peerDot = $("peerDot"),
          wordCount = $("wordCount"), statusDot = $("statusDot"),
          storyBox = $("storyBox"), turnBanner = $("turnBanner"),
          wordInput = $("wordInput"), submitBtn = $("submitBtn"),
          colourPicker = $("colourPicker"), colourSwatch = $("colourSwatch"),
          copyBtn = $("copyBtn"), downloadBtn = $("downloadBtn"), leaveBtn = $("leaveBtn"),
          errorBox = $("errorBox");

    // State
    let sessionId = null;        // friendly label (shown in UI)
    let derivedKey = null;       // hashed key used for Firebase paths
    let myUid = null, myName = null, peerName = null, unsubSession = null;
    let audioCtx = null, canPlaySound = false, wasMyTurn = null;

    // ----- Stable client id for seat reclaim -----
    const CID_KEY = "storytag_client_id";
    function getClientId() {
      let cid = localStorage.getItem(CID_KEY);
      if (!cid) { cid = "c_" + Math.random().toString(36).slice(2,12); localStorage.setItem(CID_KEY, cid); }
      return cid;
    }
    const clientId = getClientId();

    // Local backups & remembered sessions (no passwords stored)
    const LS_KEY = "storytag_state_v1";
    function saveLocal(state) { localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function loadLocal() { try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); } catch { return {}; } }

    const REM_KEY = "storytag_remembered_sessions_v1";
    function loadRememberMap(){ try { return JSON.parse(localStorage.getItem(REM_KEY) || "{}"); } catch { return {}; } }
    function saveRememberMap(map){ localStorage.setItem(REM_KEY, JSON.stringify(map)); }
    function setSavedHintText(sid){
      const map = loadRememberMap();
      if (sid && map[sid]) {
        savedHint.innerHTML = `Saved on this device — password optional. <a id="forgetLink" class="link">Forget</a>`;
        setTimeout(() => {
          const forget = document.getElementById("forgetLink");
          if (forget) forget.onclick = () => {
            const m = loadRememberMap(); delete m[sid]; saveRememberMap(m);
            savedHint.textContent = "Removed saved key.";
          };
        }, 0);
      } else savedHint.textContent = "";
    }

    // Word regex (letters, apostrophes, hyphens, optional trailing .,!?)
    const WORD_RX = /^[A-Za-z]+(?:['-][A-Za-z]+)*(?:[.,!?])?$/;

    // Utils
    function titleCaseFirstWordIfNeeded(i, word) { return (i === 0 && word.length) ? word[0].toUpperCase() + word.slice(1) : word; }
    function setUIConnected(connected) { statusDot.textContent = connected ? "Connected" : "Offline"; }
    function escapeHtml(s) { return (s || "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c])); }
    function setDotColour(el, colour, present) { el.style.background = present ? (colour || "#666") : "#666"; el.style.boxShadow = "0 0 0 1px rgba(255,255,255,.12) inset"; }
    function setMyColourUI(hex){ if (!hex) return; colourSwatch.style.background = hex; youDot.style.background = hex; }

    // Crypto helpers: SHA-256 + base64url
    async function sha256Base64Url(input) {
      const enc = new TextEncoder();
      const hash = await crypto.subtle.digest("SHA-256", enc.encode(input));
      const bytes = new Uint8Array(hash);
      let bin = ""; for (let b of bytes) bin += String.fromCharCode(b);
      return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
    }

    // Render story
    function renderStory(words, players) {
      storyBox.innerHTML = "";
      if (!words.length) { storyBox.textContent = "(No words yet—be the first to write!)"; wordCount.textContent = "0"; return; }
      for (const w of words) {
        const span = document.createElement("span"); span.className = "word";
        span.style.color = players?.[w.by]?.colour || "#c6cdff";
        span.textContent = w.w; storyBox.appendChild(span);
      }
      wordCount.textContent = String(words.length);
    }

    function setTurnBanner(currentTurnUid, players) {
      if (!players || !players[myUid]) { turnBanner.textContent = "Waiting…"; return; }
      const mine = currentTurnUid === myUid;
      const theirUid = Object.keys(players).find(k => k !== myUid);
      const their = theirUid ? players[theirUid] : null;
      if (mine) { turnBanner.innerHTML = `It’s <span class="turn">your</span> turn to write`; }
      else if (their) { const safeName = escapeHtml(their?.name || "Partner"); turnBanner.innerHTML = `<span class="nameTag">${safeName}</span>’s turn to write`; }
      else { turnBanner.textContent = "Waiting for partner…"; }
      submitBtn.disabled = !mine; wordInput.disabled = !mine; if (mine) wordInput.focus();
    }

    // Sound ping
    function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    function playTurnSound() {
      if (!canPlaySound) return;
      try {
        ensureAudio(); const now = audioCtx.currentTime;
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.12, now + 0.01); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35); g.connect(audioCtx.destination);
        const o = audioCtx.createOscillator(); o.type = "sine"; o.frequency.setValueAtTime(660, now); o.frequency.linearRampToValueAtTime(880, now + 0.2); o.connect(g); o.start(now); o.stop(now + 0.35);
      } catch {}
    }

    // Prefill & hint
    (function tryResume() {
      const saved = loadLocal();
      if (saved.sessionId && saved.myName) { nameInput.value = saved.myName; sessionInput.value = saved.sessionId; }
      setSavedHintText(saved.sessionId || "");
    })();
    sessionInput.addEventListener("input", () => setSavedHintText(sessionInput.value.trim()));

    // ---------- Core enter function (mode: 'create' | 'join') ----------
    async function enterSession(mode) {
      canPlaySound = true;
      errorBox.textContent = "";
      const name = nameInput.value.trim();
      const sid = sessionInput.value.trim();
      const pwd = passwordInput.value;

      if (!name) { joinStatus.innerHTML = '<span class="err">Enter your name</span>'; return; }
      if (!sid)  { joinStatus.innerHTML = '<span class="err">Enter a session ID</span>'; return; }

      joinBtn.disabled = true; createBtn.disabled = true;
      joinStatus.textContent = mode === 'create' ? "Creating…" : "Joining…";

      try {
        // derive or load key
        const remembered = loadRememberMap();
        if (mode === 'join' && !pwd && remembered[sid]) {
          derivedKey = remembered[sid];
        } else {
          if (!pwd) { joinStatus.innerHTML = '<span class="err">Enter a password</span>'; joinBtn.disabled = false; createBtn.disabled = false; return; }
          derivedKey = await sha256Base64Url(`${sid}:${pwd}`);
        }

        sessionId = sid;

        const sesRef = ref(db, `sessions/${derivedKey}`);
        const snap = await get(sesRef);
        const exists = snap.exists();
        const existing = snap.val() || {};
        const players = existing.players || {};

        if (mode === 'create' && exists) {
          joinStatus.innerHTML = '<span class="warn">A session with this ID+password already exists. Use Join instead or pick a different combo.</span>';
          joinBtn.disabled = false; createBtn.disabled = false;
          return;
        }
        if (mode === 'join' && !exists) {
          joinStatus.innerHTML = '<span class="warn">No session found for that ID+password. Did you mean to Create?</span>';
          joinBtn.disabled = false; createBtn.disabled = false;
          return;
        }

        // Reuse seat if our clientId already exists
        let reuseUid = Object.keys(players).find(uid => players[uid]?.clientId === getClientId());
        myUid = reuseUid || ("u_" + Math.random().toString(36).slice(2, 10));
        myName = name;

        // Enforce max 2 seats, BUT allow if we're reclaiming
        const seatCount = Object.keys(players).length;
        if (seatCount >= 2 && !reuseUid) {
          joinStatus.innerHTML = '<span class="err">Session is full (2/2)</span>';
          joinBtn.disabled = false; createBtn.disabled = false; return;
        }

        // Create session doc if needed
        if (!exists && mode === 'create') {
          await set(sesRef, { createdAt: serverTimestamp(), friendlyId: sessionId, words: [], currentTurnUid: myUid, players: {} });
        } else if (exists && !existing.friendlyId) {
          await update(sesRef, { friendlyId: existing.friendlyId || sessionId });
        }

        // Same-name disambiguation (only if not reclaiming and we’re the second)
        if (!reuseUid && seatCount === 1) {
          const [otherUid] = Object.keys(players);
          if (players[otherUid]?.name?.trim().toLowerCase() === name.toLowerCase()) {
            myName = `${name} (2)`;
          }
        }

        // Default colour
        const defaultColour = colourPicker.value || `#${Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,"0")}`;

        // Write/overwrite my seat atomically with clientId
        const myPlayerRef = ref(db, `sessions/${derivedKey}/players/${myUid}`);
        await set(myPlayerRef, {
          uid: myUid,
          clientId: getClientId(),
          name: myName,
          colour: players[myUid]?.colour || defaultColour,
          joinedAt: serverTimestamp()
        });

        // Free seat on disconnect
        onDisconnect(myPlayerRef).remove();

        // Remember this session locally (store derivedKey, never the password)
        if (rememberChk.checked) {
          const map = loadRememberMap(); map[sessionId] = derivedKey; saveRememberMap(map);
          setSavedHintText(sessionId);
        }

        // UI switch
        auth.style.display = "none";
        game.style.display = "block";
        sessionLabel.textContent = sessionId;
        youLabel.textContent = myName;
        colourPicker.value = players[myUid]?.colour || defaultColour;
        setMyColourUI(colourPicker.value);

        // Subscribe to session changes
        if (unsubSession) unsubSession();
        unsubSession = onValue(sesRef, (s) => {
          const val = s.val() || {};
          const players = val.players || {};
          const words = val.words || [];
          let cturn = val.currentTurnUid;
          const ids = Object.keys(players);

          // Peer info
          const peerId = ids.find(k => k !== myUid);
          peerLabel.textContent = peerId ? (players[peerId]?.name || "Partner") : "(none)";

          // Dots use chosen colours (grey if seat missing)
          setDotColour(youDot, players[myUid]?.colour, !!players[myUid]);
          setDotColour(peerDot, players[peerId]?.colour, !!players[peerId]);

          // Status
          setUIConnected(ids.length > 0);

          // Story
          renderStory(words, players);

          // If turn belongs to a missing player, hand to whoever is present
          if (cturn && !players[cturn] && ids.length > 0) {
            const newTurn = ids[0];
            update(sesRef, { currentTurnUid: newTurn });
            cturn = newTurn;
          }

          // Solo lock after first word
          if (ids.length < 2 && words.length > 0) {
            submitBtn.disabled = true; wordInput.disabled = true; turnBanner.textContent = "Waiting for partner…";
          } else {
            setTurnBanner(cturn, players);
          }

          // Auto-handoff when partner arrives
          const last = words[words.length - 1];
          if (ids.length === 2 && last && last.by === myUid && cturn === myUid && peerId) {
            update(sesRef, { currentTurnUid: peerId });
          }

          // Turn sound
          const isMyTurn = (cturn === myUid) && (ids.length === 2);
          if (wasMyTurn === false && isMyTurn) playTurnSound();
          if (wasMyTurn === null) wasMyTurn = isMyTurn; else wasMyTurn = isMyTurn;

          // Save local (no password stored)
          saveLocal({ sessionId, myName });
        });

        wordInput.focus();
        joinStatus.innerHTML = '<span class="ok">Ready!</span>';

      } catch (e) {
        console.error(e);
        joinStatus.innerHTML = '<span class="err">Failed. Check console & Firebase config.</span>';
      } finally {
        joinBtn.disabled = false; createBtn.disabled = false;
      }
    }

    // Buttons
    createBtn.onclick = () => enterSession('create');
    joinBtn.onclick = () => enterSession('join');

    // Colour picker change -> update swatch + Firebase
    colourPicker.addEventListener("input", async () => {
      try {
        if (!derivedKey || !myUid) return;
        const hex = colourPicker.value;
        setMyColourUI(hex);
        await update(ref(db, `sessions/${derivedKey}/players/${myUid}`), { colour: hex });
      } catch (e) { console.error(e); }
    });

    // Submit word
    submitBtn.onclick = async () => {
      errorBox.textContent = "";
      let word = (wordInput.value || "").trim();
      if (!word) return;

      const sesRef = ref(db, `sessions/${derivedKey}`);
      const sesSnap = await get(sesRef);
      const ses = sesSnap.val();
      if (!ses) { errorBox.textContent = "Session not found."; return; }

      if (ses.currentTurnUid !== myUid) { errorBox.textContent = "Not your turn yet."; wordInput.value = ""; return; }
      if (!WORD_RX.test(word)) { errorBox.textContent = "Invalid word. Use letters, apostrophes, hyphens, optional .,!? at end."; return; }

      const words = Array.isArray(ses.words) ? ses.words : [];
      const players = ses.players || {};
      const peerUid = Object.keys(players).find(k => k !== myUid);

      try {
        const nextTurnUid = peerUid || myUid;
        await update(sesRef, {
          words: [...words, { w: titleCaseFirstWordIfNeeded(words.length, word), by: myUid, t: Date.now() }],
          currentTurnUid: nextTurnUid
        });

        if (!peerUid) { submitBtn.disabled = true; wordInput.disabled = true; turnBanner.textContent = "Waiting for partner…"; }
        wordInput.value = "";
      } catch (e) { console.error(e); errorBox.textContent = "Failed to add word. Check your connection."; }
    };

    // Copy / Download / Leave
    copyBtn.onclick = async () => {
      const text = [...document.querySelectorAll("#storyBox .word")].map(el => el.textContent).join(" ");
      await navigator.clipboard.writeText(text);
      copyBtn.textContent = "Copied!"; setTimeout(() => (copyBtn.textContent = "Copy story"), 1200);
    };
    downloadBtn.onclick = () => {
      const text = [...document.querySelectorAll("#storyBox .word")].map(el => el.textContent).join(" ");
      const blob = new Blob([text], { type: "text/plain" });
      const a = document.createElement("a"); a.href = URL.createObjectURL(blob);
      a.download = `story-${sessionId || "session"}.txt`; a.click(); URL.revokeObjectURL(a.href);
    };
    leaveBtn.onclick = async () => { try { if (derivedKey && myUid) await remove(ref(db, `sessions/${derivedKey}/players/${myUid}`)); } catch {} location.reload(); };

    // Keyboard shortcuts
    wordInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitBtn.click(); });
    sessionInput.addEventListener("keydown", (e) => { if (e.key === "Enter") joinBtn.click(); });
    passwordInput.addEventListener("keydown", (e) => { if (e.key === "Enter") joinBtn.click(); });

    // Minor status tweak on tab hide/show
    document.addEventListener("visibilitychange", () => { statusDot.textContent = document.hidden ? "Background" : "Connected"; });
  </script>

  <div style="position:fixed;bottom:10px;left:50%;transform:translateX(-50%);font-size:12px;color:#9aa3d7;">
    Built for fun — share your Session ID + Password with a friend and take turns!
  </div>
</body>
</html>
