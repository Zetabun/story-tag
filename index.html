<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Story Tag — Two-Player Word Game</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    body { margin: 0; background:#0f1220; color:#f5f7ff; display:flex; min-height:100vh; }
    .wrap { margin:auto; width:min(900px, 92vw); padding:24px; }
    .card { background:#171a2b; border:1px solid #2a2f4a; border-radius:14px; padding:20px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    h1 { margin:0 0 6px; font-size: clamp(24px, 4vw, 34px); letter-spacing:.3px; }
    p.sub { margin:0 0 18px; color:#b9c0ff; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    label { font-size:14px; color:#b9c0ff; }
    input[type="text"], input[type="password"] { width:100%; padding:12px 14px; border-radius:10px; border:1px solid #303659; background:#0f1328; color:#fff; }
    input[type="text"]::placeholder, input[type="password"]::placeholder { color:#8890b3; }
    input[disabled] { opacity:.6; }
    button { padding:12px 16px; border-radius:10px; border:1px solid #39406a; background:#2a2f4a; color:#fff; cursor:pointer; transition:.15s transform ease; }
    button:hover { transform: translateY(-1px); }
    button:disabled { opacity:.55; cursor:not-allowed; transform:none; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hint { font-size:13px; color:#9aa3d7; }
    .ok { color:#69f0ae; }
    .err { color:#ff6b6b; }
    .warn { color:#ffd166; }
    .story { background:#0c0f22; border:1px solid #2a2f4a; border-radius:12px; padding:14px; min-height:100px; line-height:1.6; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
    .pill { padding:6px 10px; border-radius:999px; background:#1c2142; border:1px solid #2a2f4a; color:#c6cdff; font-size:12px; display:flex; align-items:center; gap:8px; }
    .muted { color:#9aa3d7; font-size:14px; }
    .spacer { height:10px; }
    .turn { font-weight:600; }
    .nameTag { font-weight:700; }
    .small { font-size:12px; color:#9aa3d7; }
    .divider { height:1px; background:#2a2f4a; margin:14px 0; }
    .tag { display:inline-flex; align-items:center; gap:6px; }
    .dot { width:10px; height:10px; border-radius:50%; background:#666; box-shadow: 0 0 0 1px rgba(255,255,255,.12) inset; }
    /* coloured words */
    .word { display:inline; }
    .word + .word::before { content: " "; }
    /* colour swatch + input overlay */
    .colourWrap { position: relative; display: inline-block; }
    .swatch{
      width:28px; height:14px; border-radius:7px;
      border:1px solid #2a2f4a; background:#58a6ff;
      display:inline-block; vertical-align:middle;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }
    .swatchInput{ position:absolute; inset:0; opacity:0; cursor:pointer; }

    /* Presence badge styling */
    .presence { font-weight:600; }
    .online { color:#69f0ae; }
    .away { color:#ffd166; }
    .offline { color:#b0b7e1; }

    /* Mobile responsive tweaks */
    @media (max-width: 768px) {
      .row { gap:8px; }
      .pill { font-size:11px; padding:6px 8px; }
      .story { min-height:120px; font-size:16px; }
      #wordInput { flex:1 1 100%; }
      #submitBtn { flex:1 1 100%; }
      .toolbar button { flex:1 1 calc(50% - 8px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Story Tag</h1>
      <p class="sub">Create a private session with an ID + password, then share both with a friend. Take turns adding one word to build a story.</p>

      <div id="auth" class="grid">
        <div>
          <label for="name">Your name</label>
          <input id="name" type="text" maxlength="24" placeholder="e.g., Alex" />
        </div>
        <div>
          <label for="sessionId">Session ID</label>
          <input id="sessionId" type="text" maxlength="32" placeholder="e.g., 343w4 (friendly name)" />
          <div class="small hint">This is a friendly label. Privacy comes from the password-derived key.</div>
        </div>
        <div>
          <label for="password">Password</label>
          <input id="password" type="password" maxlength="64" placeholder="Required once unless remembered" />
          <div class="small hint" id="savedHint"></div>
        </div>
        <div class="row">
          <label class="small"><input id="rememberChk" type="checkbox" /> Remember this session on this device</label>
        </div>
        <div class="row">
          <button id="createBtn">Create session</button>
          <button id="joinBtn">Join session</button>
          <div id="joinStatus" class="small"></div>
        </div>
      </div>

      <div id="game" style="display:none">
        <div class="row">
          <div class="pill">Session: <span id="sessionLabel"></span></div>
          <div class="pill">You:
            <span class="tag">
              <span id="youDot" class="dot"></span>
              <span id="youLabel" class="nameTag"></span>
              <span id="youPresence" class="presence offline">(offline)</span>
            </span>
          </div>
          <div class="pill">Partner:
            <span class="tag">
              <span id="peerDot" class="dot"></span>
              <span id="peerLabel"></span>
              <span id="peerPresence" class="presence offline">(offline)</span>
            </span>
          </div>
          <div class="pill">Words: <span id="wordCount">0</span></div>
          <div class="pill">Status: <span id="statusDot">Waiting…</span></div>
          <div class="pill">
            Colour:
            <span class="colourWrap">
              <span id="colourSwatch" class="swatch" title="Pick your colour"></span>
              <input id="colourPicker" type="color" class="swatchInput" value="#58a6ff" />
            </span>
          </div>
        </div>

        <div class="divider"></div>

        <div class="story" id="storyBox" aria-live="polite">(No words yet—be the first to write!)</div>
        <div class="spacer"></div>

        <div id="turnBanner" class="muted">Waiting for partner…</div>
        <div class="spacer"></div>

        <div class="row">
          <input id="wordInput" type="text" placeholder="Your word…" autocomplete="off" />
          <button id="submitBtn">Add Word</button>
        </div>
        <div class="hint">Rules: one word per turn. Letters, apostrophes, hyphens, and optional punctuation at the end (. , ! ?) allowed.</div>

        <div class="divider"></div>

        <div class="toolbar">
          <button id="copyBtn">Copy story</button>
          <button id="downloadBtn">Download .txt</button>
          <button id="leaveBtn">Leave session</button>
        </div>
        <div id="errorBox" class="small err"></div>
      </div>
    </div>
  </div>

  <!-- Firebase via CDN -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, get, set, update, onValue, serverTimestamp,
      onDisconnect, remove
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCVOzSTr3lPRm1BRzKTJtdEG-nsdnVIhiM", // <— NEW KEY
      authDomain: "zetabun-91b0c.firebaseapp.com",
      databaseURL: "https://zetabun-91b0c-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "zetabun-91b0c",
      storageBucket: "zetabun-91b0c.firebasestorage.app",
      messagingSenderId: "594713569270",
      appId: "1:594713569270:web:fa1d230bd5fd1ce28549d7",
      measurementId: "G-SQR25FYPLC"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Elements
    const $ = id => document.getElementById(id);
    const createBtn = $("createBtn"), joinBtn = $("joinBtn"), joinStatus = $("joinStatus"),
          auth = $("auth"), game = $("game"),
          nameInput = $("name"), sessionInput = $("sessionId"), passwordInput = $("password"),
          rememberChk = $("rememberChk"), savedHint = $("savedHint"),
          sessionLabel = $("sessionLabel"),
          youLabel = $("youLabel"), peerLabel = $("peerLabel"),
          youDot = $("youDot"), peerDot = $("peerDot"),
          youPresence = $("youPresence"), peerPresence = $("peerPresence"),
          wordCount = $("wordCount"), statusDot = $("statusDot"),
          storyBox = $("storyBox"), turnBanner = $("turnBanner"),
          wordInput = $("wordInput"), submitBtn = $("submitBtn"),
          colourPicker = $("colourPicker"), colourSwatch = $("colourSwatch"),
          copyBtn = $("copyBtn"), downloadBtn = $("downloadBtn"), leaveBtn = $("leaveBtn"),
          errorBox = $("errorBox");

    // ----- Stable client id for seat reclaim -----
    const CID_KEY = "storytag_client_id";
    function getClientId() {
      let cid = localStorage.getItem(CID_KEY);
      if (!cid) { cid = "c_" + Math.random().toString(36).slice(2,12); localStorage.setItem(CID_KEY, cid); }
      return cid;
    }
    const clientId = getClientId();

    // Local storage
    const LS_KEY = "storytag_state_v1"; // { sessionId, myName }
    const REM_KEY = "storytag_remembered_sessions_v1"; // { [sessionId]: derivedKey }
    const LAST_KEY = "storytag_last_session_v1"; // { sessionId, derivedKey, myName }
    function saveLocal(state) { localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function loadLocal() { try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); } catch { return {}; } }
    function loadRememberMap(){ try { return JSON.parse(localStorage.getItem(REM_KEY) || "{}"); } catch { return {}; } }
    function saveRememberMap(map){ localStorage.setItem(REM_KEY, JSON.stringify(map)); }
    function saveLastSession(obj){ localStorage.setItem(LAST_KEY, JSON.stringify(obj || {})); }
    function loadLastSession(){ try { return JSON.parse(localStorage.getItem(LAST_KEY) || "null"); } catch { return null; } }

    // Presence thresholds
    const ONLINE_MS = 20 * 1000;
    const AWAY_MS = 2 * 60 * 1000;

    // Friendly hints
    function setSavedHintText(sid){
      const map = loadRememberMap();
      if (sid && map[sid]) {
        savedHint.innerHTML = `Saved on this device — password optional.`;
      } else savedHint.textContent = "";
    }

    // Word regex (letters, apostrophes, hyphens, optional trailing .,!?)
    const WORD_RX = /^[A-Za-z]+(?:['-][A-Za-z]+)*(?:[.,!?])?$/;

    // Utils
    function titleCaseFirstWordIfNeeded(i, word) { return (i === 0 && word.length) ? word[0].toUpperCase() + word.slice(1) : word; }
    function setUIConnected(connected) { statusDot.textContent = connected ? "Connected" : "Offline"; }
    function escapeHtml(s) { return (s || "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c])); }
    function setDotColour(el, colour, present) { el.style.background = present ? (colour || "#666") : "#666"; el.style.boxShadow = "0 0 0 1px rgba(255,255,255,.12) inset"; }
    function setMyColourUI(hex){ if (!hex) return; colourSwatch.style.background = hex; youDot.style.background = hex; }
    function presenceOf(ts) {
      const now = Date.now();
      const d = now - (ts || 0);
      if (!ts) return {cls:"offline", label:"(offline)"};
      if (d <= ONLINE_MS) return {cls:"online", label:"(online)"};
      if (d <= AWAY_MS)   return {cls:"away", label:"(away)"};
      return {cls:"offline", label:"(offline)"};
    }

    // Crypto: SHA-256 → base64url
    async function sha256Base64Url(input) {
      const enc = new TextEncoder();
      const hash = await crypto.subtle.digest("SHA-256", enc.encode(input));
      const bytes = new Uint8Array(hash);
      let bin = ""; for (let b of bytes) bin += String.fromCharCode(b);
      return btoa(bin).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
    }

    // Render story — merge local colour override before using players map
    const localColour = { }; // uid -> hex (ensures instant colour persistence)
    function renderStory(words, players) {
      storyBox.innerHTML = "";
      if (!words.length) { storyBox.textContent = "(No words yet—be the first to write!)"; wordCount.textContent = "0"; return; }
      for (const w of words) {
        const span = document.createElement("span");
        span.className = "word";
        const colour = (players?.[w.by]?.colour) || localColour[w.by] || "#c6cdff";
        span.style.color = colour;
        span.textContent = w.w;
        storyBox.appendChild(span);
      }
      wordCount.textContent = String(words.length);
    }

    function setTurnBanner(currentTurnUid, players, myUid) {
      if (!players || !players[myUid]) { turnBanner.textContent = "Waiting…"; return; }
      const mine = currentTurnUid === myUid;
      const theirUid = Object.keys(players).find(k => k !== myUid);
      const their = theirUid ? players[theirUid] : null;
      if (mine) { turnBanner.innerHTML = `It’s <span class="turn">your</span> turn to write`; }
      else if (their) { const safeName = escapeHtml(their?.name || "Partner"); turnBanner.innerHTML = `<span class="nameTag">${safeName}</span>’s turn to write`; }
      else { turnBanner.textContent = "Waiting for partner…"; }
      submitBtn.disabled = !mine; wordInput.disabled = !mine; if (mine) wordInput.focus();
    }

    // Sound
    let audioCtx = null, canPlaySound = false, wasMyTurn = null;
    function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    function playTurnSound() {
      if (!canPlaySound) return;
      try {
        ensureAudio(); const now = audioCtx.currentTime;
        const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.12, now + 0.01); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35); g.connect(audioCtx.destination);
        const o = audioCtx.createOscillator(); o.type = "sine"; o.frequency.setValueAtTime(660, now); o.frequency.linearRampToValueAtTime(880, now + 0.2); o.connect(g); o.start(now); o.stop(now + 0.35);
      } catch {}
    }

    // Prefill & hint
    (function tryPrefill() {
      const saved = loadLocal();
      if (saved.sessionId && saved.myName) { nameInput.value = saved.myName; sessionInput.value = saved.sessionId; setSavedHintText(saved.sessionId); }
    })();
    sessionInput.addEventListener("input", () => setSavedHintText(sessionInput.value.trim()));

    // ---------- Enter session (mode: 'create' | 'join'); supports silent auto-resume ----------
    async function enterSession(mode, opts = {}) {
      const { auto = false } = opts;
      if (!auto) canPlaySound = true;

      errorBox.textContent = "";
      const name = (opts.myNameOverride ?? nameInput.value).trim();
      const sid  = (opts.sessionIdOverride ?? sessionInput.value).trim();
      const pwd  = opts.passwordOverride ?? passwordInput.value;

      if (!name) { if (!auto) joinStatus.innerHTML = '<span class="err">Enter your name</span>'; return; }
      if (!sid)  { if (!auto) joinStatus.innerHTML = '<span class="err">Enter a session ID</span>'; return; }

      if (!auto) { joinBtn.disabled = true; createBtn.disabled = true; joinStatus.textContent = mode === 'create' ? "Creating…" : "Joining…"; }

      try {
        // derive/load key
        const remembered = loadRememberMap();
        let derivedKey = opts.derivedKeyOverride || null;
        if (!derivedKey) {
          if (mode === 'join' && !pwd && remembered[sid]) {
            derivedKey = remembered[sid];
          } else {
            if (!pwd) { if (!auto) { joinStatus.innerHTML = '<span class="err">Enter a password</span>'; } return; }
            derivedKey = await sha256Base64Url(`${sid}:${pwd}`);
          }
        }

        const sesRef = ref(db, `sessions/${derivedKey}`);
        const snap = await get(sesRef);
        const exists = snap.exists();
        const existing = snap.val() || {};
        const players = existing.players || {};

        if (mode === 'create' && exists) { if (!auto) joinStatus.innerHTML = '<span class="warn">Session already exists. Use Join.</span>'; return; }
        if (mode === 'join' && !exists) { if (!auto) joinStatus.innerHTML = '<span class="warn">No session found. Use Create.</span>'; return; }

        // Reuse seat by clientId
        let myUid = Object.keys(players).find(uid => players[uid]?.clientId === clientId) || ("u_" + Math.random().toString(36).slice(2, 10));
        let myName = name;

        // Seat cap
        const seatCount = Object.keys(players).length;
        if (seatCount >= 2 && !players[myUid]) { if (!auto) joinStatus.innerHTML = '<span class="err">Session is full (2/2)</span>'; return; }

        // Create if needed
        if (!exists && mode === 'create') {
          await set(sesRef, { createdAt: serverTimestamp(), friendlyId: sid, words: [], currentTurnUid: myUid, players: {} });
        } else if (exists && !existing.friendlyId) {
          await update(sesRef, { friendlyId: existing.friendlyId || sid });
        }

        // Name disambiguation
        if (!players[myUid] && seatCount === 1) {
          const [otherUid] = Object.keys(players);
          if (players[otherUid]?.name?.trim().toLowerCase() === name.toLowerCase()) myName = `${name} (2)`;
        }

        // Default colour
        const defaultColour = colourPicker.value || `#${Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,"0")}`;

        // Write seat (with presence + lastActive)
        const nowTs = Date.now();
        const myPlayerRef = ref(db, `sessions/${derivedKey}/players/${myUid}`);
        await set(myPlayerRef, {
          uid: myUid,
          clientId,
          name: myName,
          colour: players[myUid]?.colour || defaultColour,
          joinedAt: serverTimestamp(),
          lastActive: nowTs
        });
        onDisconnect(myPlayerRef).remove();

        // Remember session locally
        if (!auto && rememberChk.checked) {
          const map = loadRememberMap(); map[sid] = derivedKey; saveRememberMap(map); setSavedHintText(sid);
        }
        saveLastSession({ sessionId: sid, derivedKey, myName });

        // Switch UI
        auth.style.display = "none";
        game.style.display = "block";
        sessionLabel.textContent = sid;
        youLabel.textContent = myName;
        colourPicker.value = players[myUid]?.colour || defaultColour;
        localColour[myUid] = colourPicker.value; // local override for instant persistence
        setMyColourUI(colourPicker.value);

        // Subscribe
        if (window._unsub) window._unsub();
        window._unsub = onValue(sesRef, (s) => {
          const val = s.val() || {};
          const players = val.players || {};
          const words = val.words || [];
          let cturn = val.currentTurnUid;
          const ids = Object.keys(players);
          const peerId = ids.find(k => k !== myUid);

          // Presence labels
          const meP = presenceOf(players[myUid]?.lastActive);
          const peP = presenceOf(players[peerId]?.lastActive);
          youPresence.className = `presence ${meP.cls}`; youPresence.textContent = meP.label;
          peerPresence.className = `presence ${peP.cls}`; peerPresence.textContent = peP.label;

          // Names & dots
          peerLabel.textContent = peerId ? (players[peerId]?.name || "Partner") : "(none)";
          // Merge local colour override so story doesn't flicker to white
          const mergedPlayers = JSON.parse(JSON.stringify(players || {}));
          if (localColour[myUid]) { mergedPlayers[myUid] = mergedPlayers[myUid] || {}; mergedPlayers[myUid].colour = localColour[myUid]; }
          setDotColour(youDot, mergedPlayers[myUid]?.colour, !!mergedPlayers[myUid]);
          setDotColour(peerDot, mergedPlayers[peerId]?.colour, !!mergedPlayers[peerId]);

          setUIConnected(ids.length > 0);
          renderStory(words, mergedPlayers);

          // Fix turn if missing player
          if (cturn && !players[cturn] && ids.length > 0) {
            const newTurn = ids[0];
            update(sesRef, { currentTurnUid: newTurn });
            cturn = newTurn;
          }

          // Solo lock after first word
          if (ids.length < 2 && words.length > 0) {
            submitBtn.disabled = true; wordInput.disabled = true; turnBanner.textContent = "Waiting for partner…";
          } else {
            setTurnBanner(cturn, players, myUid);
          }

          // Auto-handoff when partner arrives
          const last = words[words.length - 1];
          if (ids.length === 2 && last && last.by === myUid && cturn === myUid && peerId) {
            update(sesRef, { currentTurnUid: peerId });
          }

          // Turn sound
          const isMyTurn = (cturn === myUid) && (ids.length === 2);
          if (wasMyTurn === false && isMyTurn) playTurnSound();
          if (wasMyTurn === null) wasMyTurn = isMyTurn; else wasMyTurn = isMyTurn;

          // Save lightweight state
          saveLocal({ sessionId: sid, myName });
        });

        if (!auto) { wordInput.focus(); joinStatus.innerHTML = '<span class="ok">Ready!</span>'; }

        // Presence heartbeat (every 10s + on interactions)
        if (window._presenceTimer) clearInterval(window._presenceTimer);
        window._presenceTimer = setInterval(async () => {
          try { await update(ref(db, `sessions/${derivedKey}/players/${myUid}`), { lastActive: Date.now() }); } catch {}
        }, 10000);

        const bumpPresence = async () => {
          try { await update(ref(db, `sessions/${derivedKey}/players/${myUid}`), { lastActive: Date.now() }); } catch {}
        };
        ["click","keydown","touchstart","visibilitychange"].forEach(ev => document.addEventListener(ev, bumpPresence, {passive:true}));

      } catch (e) {
        console.error(e);
        if (!auto) joinStatus.innerHTML = '<span class="err">Failed. Check console & Firebase config.</span>';
      } finally {
        if (!auto) { joinBtn.disabled = false; createBtn.disabled = false; }
      }
    }

    // Buttons
    createBtn.onclick = () => enterSession('create');
    joinBtn.onclick = () => enterSession('join');

    // Colour picker change -> update swatch + Firebase (and local override for persistence)
    colourPicker.addEventListener("input", async () => {
      try {
        const last = loadLastSession(); if (!last) return;
        const { derivedKey } = last;
        // find my uid by clientId
        const sesRef = ref(db, `sessions/${derivedKey}`);
        const snap = await get(sesRef);
        const players = (snap.val() && snap.val().players) || {};
        const myUid = Object.keys(players).find(uid => players[uid]?.clientId === clientId);
        const hex = colourPicker.value;
        localColour[myUid] = hex; // make it stick immediately
        setMyColourUI(hex);
        if (myUid) await update(ref(db, `sessions/${derivedKey}/players/${myUid}`), { colour: hex, lastActive: Date.now() });
      } catch (e) { console.error(e); }
    });

    // Submit word
    submitBtn.onclick = async () => {
      errorBox.textContent = "";
      let word = (wordInput.value || "").trim();
      if (!word) return;

      const last = loadLastSession();
      if (!last) { errorBox.textContent = "No active session."; return; }
      const { derivedKey } = last;

      const sesRef = ref(db, `sessions/${derivedKey}`);
      const sesSnap = await get(sesRef);
      const ses = sesSnap.val();
      if (!ses) { errorBox.textContent = "Session not found."; return; }

      // Find myUid by clientId
      const players = ses.players || {};
      const myUid = Object.keys(players).find(uid => players[uid]?.clientId === clientId);
      if (!myUid) { errorBox.textContent = "Rejoin required."; return; }

      if (ses.currentTurnUid !== myUid) { errorBox.textContent = "Not your turn yet."; wordInput.value = ""; return; }
      if (!WORD_RX.test(word)) { errorBox.textContent = "Invalid word. Use letters, apostrophes, hyphens, optional .,!? at end."; return; }

      const words = Array.isArray(ses.words) ? ses.words : [];
      const peerUid = Object.keys(players).find(k => k !== myUid);

      try {
        await update(sesRef, {
          words: [...words, { w: titleCaseFirstWordIfNeeded(words.length, word), by: myUid, t: Date.now() }],
          currentTurnUid: peerUid || myUid
        });
        wordInput.value = "";
        if (!peerUid) { submitBtn.disabled = true; wordInput.disabled = true; turnBanner.textContent = "Waiting for partner…"; }
        // bump presence
        await update(ref(db, `sessions/${derivedKey}/players/${myUid}`), { lastActive: Date.now() });
      } catch (e) { console.error(e); errorBox.textContent = "Failed to add word. Check your connection."; }
    };

    // Copy / Download / Leave
    copyBtn.onclick = async () => {
      const text = [...document.querySelectorAll("#storyBox .word")].map(el => el.textContent).join(" ");
      await navigator.clipboard.writeText(text);
      copyBtn.textContent = "Copied!"; setTimeout(() => (copyBtn.textContent = "Copy story"), 1200);
    };
    downloadBtn.onclick = () => {
      const last = loadLastSession();
      const fileSid = last?.sessionId || "session";
      const text = [...document.querySelectorAll("#storyBox .word")].map(el => el.textContent).join(" ");
      const blob = new Blob([text], { type: "text/plain" });
      const a = document.createElement("a"); a.href = URL.createObjectURL(blob);
      a.download = `story-${fileSid}.txt`; a.click(); URL.revokeObjectURL(a.href);
    };
    leaveBtn.onclick = async () => {
      try {
        const last = loadLastSession();
        if (last) {
          const { derivedKey } = last;
          const sesRef = ref(db, `sessions/${derivedKey}`);
          const snap = await get(sesRef);
          const players = (snap.val() && snap.val().players) || {};
          const myUid = Object.keys(players).find(uid => players[uid]?.clientId === clientId);
          if (myUid) await remove(ref(db, `sessions/${derivedKey}/players/${myUid}`));
        }
      } catch {}
      // clear auto-resume + back to login
      localStorage.removeItem(LAST_KEY);
      location.reload();
    };

    // Keyboard shortcuts
    wordInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitBtn.click(); });
    sessionInput.addEventListener("keydown", (e) => { if (e.key === "Enter") joinBtn.click(); });
    passwordInput.addEventListener("keydown", (e) => { if (e.key === "Enter") joinBtn.click(); });

    // Minor status tweak on tab hide/show
    document.addEventListener("visibilitychange", () => {
      statusDot.textContent = document.hidden ? "Background" : "Connected";
    });

    // Auto-resume on load
    (async function autoResume() {
      const last = loadLastSession();
      if (!last) return;
      if (last.sessionId) sessionInput.value = last.sessionId;
      if (last.myName) { nameInput.value = last.myName; }
      setSavedHintText(last.sessionId || "");
      await enterSession('join', {
        auto: true,
        sessionIdOverride: last.sessionId || "",
        myNameOverride: last.myName || "",
        derivedKeyOverride: last.derivedKey || null
      });
    })();
  </script>

  <div style="position:fixed;bottom:10px;left:50%;transform:translateX(-50%);font-size:12px;color:#9aa3d7;">
    Built for fun — share your Session ID + Password with a friend and take turns!
  </div>
</body>
</html>
