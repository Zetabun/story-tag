<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Story Tag — Two-Player Word Game</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    body { margin: 0; background:#0f1220; color:#f5f7ff; display:flex; min-height:100vh; }
    .wrap { margin:auto; width:min(900px, 92vw); padding:24px; }
    .card { background:#171a2b; border:1px solid #2a2f4a; border-radius:14px; padding:20px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    h1 { margin:0 0 6px; font-size: clamp(24px, 4vw, 34px); letter-spacing:.3px; }
    p.sub { margin:0 0 18px; color:#b9c0ff; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    label { font-size:14px; color:#b9c0ff; }
    input[type="text"] { width:100%; padding:12px 14px; border-radius:10px; border:1px solid #303659; background:#0f1328; color:#fff; }
    input[type="text"]::placeholder { color:#8890b3; }
    input[disabled] { opacity:.6; }
    button { padding:12px 16px; border-radius:10px; border:1px solid #39406a; background:#2a2f4a; color:#fff; cursor:pointer; transition:.15s transform ease; }
    button:hover { transform: translateY(-1px); }
    button:disabled { opacity:.55; cursor:not-allowed; transform:none; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hint { font-size:13px; color:#9aa3d7; }
    .ok { color:#69f0ae; }
    .err { color:#ff6b6b; }
    .story { background:#0c0f22; border:1px solid #2a2f4a; border-radius:12px; padding:14px; min-height:100px; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
    .pill { padding:6px 10px; border-radius:999px; background:#1c2142; border:1px solid #2a2f4a; color:#c6cdff; font-size:12px; display:flex; align-items:center; gap:8px; }
    .muted { color:#9aa3d7; font-size:14px; }
    .spacer { height:10px; }
    .turn { font-weight:600; }
    .nameTag { font-weight:700; }
    .small { font-size:12px; color:#9aa3d7; }
    .divider { height:1px; background:#2a2f4a; margin:14px 0; }
    .tag { display:inline-flex; align-items:center; gap:6px; }
    .dot { width:8px; height:8px; border-radius:50%; background:#666; box-shadow: 0 0 0 1px rgba(255,255,255,.12) inset; }
    /* coloured words */
    .word { display:inline; }
    .word + .word::before { content: " "; }
    /* colour swatch + input overlay */
    .colourWrap { position: relative; display: inline-block; }
    .swatch{
      width:28px; height:14px; border-radius:7px;
      border:1px solid #2a2f4a; background:#58a6ff;
      display:inline-block; vertical-align:middle;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }
    .swatchInput{
      position:absolute; inset:0; opacity:0; cursor:pointer;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Story Tag</h1>
      <p class="sub">Enter a Session ID and your name. When someone else joins with the same ID, you’ll take turns adding one word each to build a story.</p>

      <div id="auth" class="grid">
        <div>
          <label for="name">Your name</label>
          <input id="name" type="text" maxlength="24" placeholder="e.g., Alex" />
        </div>
        <div>
          <label for="sessionId">Session ID</label>
          <input id="sessionId" type="text" maxlength="12" placeholder="e.g., 343w4" />
          <div class="small hint">Exactly two players per session. Reuse the same ID to rejoin.</div>
        </div>
        <div class="row">
          <button id="joinBtn">Join Session</button>
          <div id="joinStatus" class="small"></div>
        </div>
      </div>

      <div id="game" style="display:none">
        <div class="row">
          <div class="pill">Session: <span id="sessionLabel"></span></div>
          <div class="pill">You:
            <span class="tag">
              <span id="youDot" class="dot"></span>
              <span id="youLabel" class="nameTag"></span>
            </span>
          </div>
          <div class="pill">Partner:
            <span class="tag">
              <span id="peerDot" class="dot"></span>
              <span id="peerLabel"></span>
            </span>
          </div>
          <div class="pill">Words: <span id="wordCount">0</span></div>
          <div class="pill">Status: <span id="statusDot">Waiting…</span></div>
          <div class="pill">
            Colour:
            <span class="colourWrap">
              <span id="colourSwatch" class="swatch" title="Pick your colour"></span>
              <input id="colourPicker" type="color" class="swatchInput" value="#58a6ff" />
            </span>
          </div>
        </div>

        <div class="divider"></div>

        <div class="story" id="storyBox" aria-live="polite">(No words yet—be the first to write!)</div>
        <div class="spacer"></div>

        <div id="turnBanner" class="muted">Waiting for partner…</div>
        <div class="spacer"></div>

        <div class="row">
          <input id="wordInput" type="text" placeholder="Your word…" autocomplete="off" />
          <button id="submitBtn">Add Word</button>
        </div>
        <div class="hint">Rules: one word per turn. Letters, apostrophes, hyphens, and optional punctuation at the end (. , ! ?) allowed.</div>

        <div class="divider"></div>

        <div class="toolbar">
          <button id="copyBtn">Copy story</button>
          <button id="downloadBtn">Download .txt</button>
          <button id="leaveBtn">Leave session</button>
        </div>
        <div id="errorBox" class="small err"></div>
      </div>
    </div>
  </div>

  <!-- Firebase via CDN -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, get, set, update, onValue, serverTimestamp,
      onDisconnect, runTransaction, remove
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDf-zLudeu9OUiDVj984bDCtoZ-ehs_uD0",
      authDomain: "zetabun-91b0c.firebaseapp.com",
      databaseURL: "https://zetabun-91b0c-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "zetabun-91b0c",
      storageBucket: "zetabun-91b0c.firebasestorage.app",
      messagingSenderId: "594713569270",
      appId: "1:594713569270:web:fa1d230bd5fd1ce28549d7",
      measurementId: "G-SQR25FYPLC"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Elements
    const $ = id => document.getElementById(id);
    const joinBtn = $("joinBtn"), joinStatus = $("joinStatus"),
          auth = $("auth"), game = $("game"),
          nameInput = $("name"), sessionInput = $("sessionId"),
          sessionLabel = $("sessionLabel"),
          youLabel = $("youLabel"), peerLabel = $("peerLabel"),
          youDot = $("youDot"), peerDot = $("peerDot"),
          wordCount = $("wordCount"), statusDot = $("statusDot"),
          storyBox = $("storyBox"), turnBanner = $("turnBanner"),
          wordInput = $("wordInput"), submitBtn = $("submitBtn"),
          colourPicker = $("colourPicker"), colourSwatch = $("colourSwatch"),
          copyBtn = $("copyBtn"), downloadBtn = $("downloadBtn"), leaveBtn = $("leaveBtn"),
          errorBox = $("errorBox");

    // State
    let sessionId = null, myUid = null, myName = null, peerName = null, unsubSession = null;
    let audioCtx = null, canPlaySound = false, wasMyTurn = null;

    // ----- Stable client id for seat reclaim -----
    const CID_KEY = "storytag_client_id";
    function getClientId() {
      let cid = localStorage.getItem(CID_KEY);
      if (!cid) { cid = "c_" + Math.random().toString(36).slice(2,12); localStorage.setItem(CID_KEY, cid); }
      return cid;
    }
    const clientId = getClientId();

    // Local backup
    const LS_KEY = "storytag_state_v1";
    function saveLocal(state) { localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    function loadLocal() { try { return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); } catch { return {}; } }

    // Word regex (letters, apostrophes, hyphens, optional trailing .,!?)
    const WORD_RX = /^[A-Za-z]+(?:['-][A-Za-z]+)*(?:[.,!?])?$/;

    // Utils
    function titleCaseFirstWordIfNeeded(i, word) { return (i === 0 && word.length) ? word[0].toUpperCase() + word.slice(1) : word; }
    function setUIConnected(connected) { statusDot.textContent = connected ? "Connected" : "Offline"; }
    function escapeHtml(s) { return (s || "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c])); }
    function setDotColour(el, colour, present) {
      el.style.background = present ? (colour || "#666") : "#666";
      el.style.boxShadow = "0 0 0 1px rgba(255,255,255,.12) inset";
    }
    function setMyColourUI(hex){
      if (!hex) return;
      colourSwatch.style.background = hex;
      youDot.style.background = hex;
    }

    // Render story as coloured spans
    function renderStory(words, players) {
      storyBox.innerHTML = "";
      if (!words.length) { storyBox.textContent = "(No words yet—be the first to write!)"; wordCount.textContent = "0"; return; }
      for (const w of words) {
        const span = document.createElement("span");
        span.className = "word";
        span.style.color = players?.[w.by]?.colour || "#c6cdff";
        span.textContent = w.w;
        storyBox.appendChild(span);
      }
      wordCount.textContent = String(words.length);
    }

    function setTurnBanner(currentTurnUid, players) {
      if (!players || !players[myUid]) { turnBanner.textContent = "Waiting…"; return; }
      const mine = currentTurnUid === myUid;
      const theirUid = Object.keys(players).find(k => k !== myUid);
      const their = theirUid ? players[theirUid] : null;
      if (mine) {
        turnBanner.innerHTML = `It’s <span class="turn">your</span> turn to write`;
      } else if (their) {
        const safeName = escapeHtml(their?.name || "Partner");
        turnBanner.innerHTML = `<span class="nameTag">${safeName}</span>’s turn to write`;
      } else {
        turnBanner.textContent = "Waiting for partner…";
      }
      submitBtn.disabled = !mine; wordInput.disabled = !mine;
      if (mine) wordInput.focus();
    }

    // Sound ping
    function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    function playTurnSound() {
      if (!canPlaySound) return;
      try {
        ensureAudio();
        const now = audioCtx.currentTime;
        const g = audioCtx.createGain();
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
        g.connect(audioCtx.destination);
        const o = audioCtx.createOscillator();
        o.type = "sine";
        o.frequency.setValueAtTime(660, now);
        o.frequency.linearRampToValueAtTime(880, now + 0.2);
        o.connect(g);
        o.start(now);
        o.stop(now + 0.35);
      } catch {}
    }

    // Prefill
    (function tryResume() {
      const saved = loadLocal();
      if (saved.sessionId && saved.myName && saved.myUid) { nameInput.value = saved.myName; sessionInput.value = saved.sessionId; }
    })();

    // Join
    joinBtn.onclick = async () => {
      canPlaySound = true;
      errorBox.textContent = "";
      const name = nameInput.value.trim();
      const sid = sessionInput.value.trim().toLowerCase();
      if (!name) { joinStatus.innerHTML = '<span class="err">Enter your name</span>'; return; }
      if (!sid) { joinStatus.innerHTML = '<span class="err">Enter a session ID</span>'; return; }

      joinBtn.disabled = true; joinStatus.textContent = "Joining…";

      try {
        sessionId = sid;

        const sesRef = ref(db, `sessions/${sessionId}`);
        const snap = await get(sesRef);
        const existing = snap.val() || {};
        const players = existing.players || {};

        // Reuse seat if a player with this clientId exists
        let reuseUid = Object.keys(players).find(uid => players[uid]?.clientId === clientId);
        myUid = reuseUid || ("u_" + Math.random().toString(36).slice(2, 10));
        myName = name;

        // Enforce max 2 seats, BUT allow if we're reclaiming
        const seatCount = Object.keys(players).length;
        if (seatCount >= 2 && !reuseUid) {
          joinStatus.innerHTML = '<span class="err">Session is full (2/2)</span>';
          joinBtn.disabled = false;
          return;
        }

        // Same-name disambiguation (only if not reclaiming and joining as second)
        if (!reuseUid && seatCount === 1) {
          const [otherUid] = Object.keys(players);
          if (players[otherUid]?.name?.trim().toLowerCase() === name.toLowerCase()) {
            myName = `${name} (2)`;
          }
        }

        // Create session if new
        if (!snap.exists()) {
          await set(sesRef, { createdAt: serverTimestamp(), words: [], currentTurnUid: myUid, players: {} });
        }

        // Default colour
        const defaultColour = colourPicker.value || `#${Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,"0")}`;

        // Write/overwrite my seat atomically with clientId
        const myPlayerRef = ref(db, `sessions/${sessionId}/players/${myUid}`);
        await set(myPlayerRef, {
          uid: myUid,
          clientId,                // <-- seat reclaim key
          name: myName,
          colour: players[myUid]?.colour || defaultColour,
          joinedAt: serverTimestamp()
        });

        // Free seat on disconnect
        onDisconnect(myPlayerRef).remove();

        // UI switch
        auth.style.display = "none";
        game.style.display = "block";
        sessionLabel.textContent = sessionId;
        youLabel.textContent = myName;
        colourPicker.value = players[myUid]?.colour || defaultColour;
        setMyColourUI(colourPicker.value);

        // Subscribe to session changes
        if (unsubSession) unsubSession();
        unsubSession = onValue(sesRef, (s) => {
          const val = s.val() || {};
          const players = val.players || {};
          const words = val.words || [];
          let cturn = val.currentTurnUid;
          const ids = Object.keys(players);

          // Peer info
          const peerId = ids.find(k => k !== myUid);
          peerName = peerId ? (players[peerId]?.name || "Partner") : null;
          peerLabel.textContent = peerName || "(none)";

          // Dots use chosen colours (grey if seat missing)
          setDotColour(youDot, players[myUid]?.colour, !!players[myUid]);
          setDotColour(peerDot, players[peerId]?.colour, !!players[peerId]);

          // Status
          setUIConnected(ids.length > 0);

          // Story
          renderStory(words, players);

          // If turn belongs to a missing player, hand to whoever is present
          if (cturn && !players[cturn] && ids.length > 0) {
            const newTurn = ids[0];
            update(sesRef, { currentTurnUid: newTurn });
            cturn = newTurn;
          }

          // Solo lock after first word
          if (ids.length < 2 && words.length > 0) {
            submitBtn.disabled = true; wordInput.disabled = true; turnBanner.textContent = "Waiting for partner…";
          } else {
            setTurnBanner(cturn, players);
          }

          // Auto-handoff when partner arrives
          const last = words[words.length - 1];
          if (ids.length === 2 && last && last.by === myUid && cturn === myUid && peerId) {
            update(sesRef, { currentTurnUid: peerId });
          }

          // Turn sound
          const isMyTurn = (cturn === myUid) && (ids.length === 2);
          if (wasMyTurn === false && isMyTurn) playTurnSound();
          if (wasMyTurn === null) wasMyTurn = isMyTurn; else wasMyTurn = isMyTurn;

          // Save local
          saveLocal({ sessionId, myUid, myName });

          // Starter if needed
          if (!cturn && ids.length === 2) {
            const sorted = ids.sort();
            update(sesRef, { currentTurnUid: sorted[0] });
          }

          // Keep picker/swatch in sync if changed elsewhere
          if (players[myUid]?.colour && colourPicker.value !== players[myUid].colour) {
            colourPicker.value = players[myUid].colour;
            setMyColourUI(players[myUid].colour);
          }
        });

        wordInput.focus();
        joinStatus.innerHTML = '<span class="ok">Joined!</span>';

      } catch (e) {
        console.error(e);
        joinStatus.innerHTML = '<span class="err">Failed to join. Check console & Firebase config.</span>';
        joinBtn.disabled = false;
      }
    };

    // Picker change -> update swatch + Firebase
    colourPicker.addEventListener("input", async () => {
      try {
        if (!sessionId || !myUid) return;
        const hex = colourPicker.value;
        setMyColourUI(hex);
        await update(ref(db, `sessions/${sessionId}/players/${myUid}`), { colour: hex });
      } catch (e) { console.error(e); }
    });

    // Submit word
    submitBtn.onclick = async () => {
      errorBox.textContent = "";
      let word = (wordInput.value || "").trim();
      if (!word) return;

      const sesRef = ref(db, `sessions/${sessionId}`);
      const sesSnap = await get(sesRef);
      const ses = sesSnap.val();
      if (!ses) { errorBox.textContent = "Session not found."; return; }

      if (ses.currentTurnUid !== myUid) { errorBox.textContent = "Not your turn yet."; wordInput.value = ""; return; }
      if (!WORD_RX.test(word)) { errorBox.textContent = "Invalid word. Use letters, apostrophes, hyphens, optional .,!? at end."; return; }

      const words = ses.words || [];
      const players = ses.players || {};
      const peerUid = Object.keys(players).find(k => k !== myUid);

      try {
        const nextTurnUid = peerUid || myUid;
        await update(sesRef, {
          words: [...words, { w: titleCaseFirstWordIfNeeded(words.length, word), by: myUid, t: Date.now() }],
          currentTurnUid: nextTurnUid
        });

        if (!peerUid) { submitBtn.disabled = true; wordInput.disabled = true; turnBanner.textContent = "Waiting for partner…"; }
        wordInput.value = "";
      } catch (e) { console.error(e); errorBox.textContent = "Failed to add word. Check your connection."; }
    };

    // Copy/Download/Leave
    copyBtn.onclick = async () => {
      const text = [...document.querySelectorAll("#storyBox .word")].map(el => el.textContent).join(" ");
      await navigator.clipboard.writeText(text);
      copyBtn.textContent = "Copied!"; setTimeout(() => (copyBtn.textContent = "Copy story"), 1200);
    };
    downloadBtn.onclick = () => {
      const text = [...document.querySelectorAll("#storyBox .word")].map(el => el.textContent).join(" ");
      const blob = new Blob([text], { type: "text/plain" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `story-${sessionId || "session"}.txt`;
      a.click(); URL.revokeObjectURL(a.href);
    };
    leaveBtn.onclick = async () => { try { if (sessionId && myUid) await remove(ref(db, `sessions/${sessionId}/players/${myUid}`)); } catch {} location.reload(); };

    // Keyboard shortcuts
    wordInput.addEventListener("keydown", (e) => { if (e.key === "Enter") submitBtn.click(); });
    sessionInput.addEventListener("keydown", (e) => { if (e.key === "Enter") joinBtn.click(); });

    // Minor status tweak on tab hide/show
    document.addEventListener("visibilitychange", () => { statusDot.textContent = document.hidden ? "Background" : "Connected"; });
  </script>

  <div style="position:fixed;bottom:10px;left:50%;transform:translateX(-50%);font-size:12px;color:#9aa3d7;">
    Built for fun — share your Session ID with a friend and take turns!
  </div>
</body>
</html>
