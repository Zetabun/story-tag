<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Story Tag — Two-Player Word Game</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    :root { --footer-h: 34px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    @media (max-width: 768px){ :root{ --footer-h: 40px; } }

    body { margin:0; background:#0f1220; color:#f5f7ff; display:flex; min-height:100vh; }
    .wrap { margin:auto; width:min(900px, 92vw); padding:24px; padding-bottom: calc(var(--footer-h) + env(safe-area-inset-bottom, 0px) + 12px); }
    .card { background:#171a2b; border:1px solid #2a2f4a; border-radius:14px; padding:20px; box-shadow:0 10px 30px rgba(0,0,0,.25); overflow:hidden; }

    h1 { margin:0 0 6px; font-size: clamp(24px, 4vw, 34px); letter-spacing:.3px; display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .version-label {
      font-size: .62em; font-weight: 500; color:#9aa3d7; letter-spacing:.4px;
      background:#12162c; border:1px solid #2a2f4a; padding:4px 8px; border-radius:999px;
    }
    .version-badge { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; color:#b9c0ff; }

    p.sub { margin:0 0 18px; color:#b9c0ff; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr; }
    label { font-size:14px; color:#b9c0ff; }
    input[type="text"], input[type="password"]{
      width:100%; max-width:100%; padding:12px 14px; border-radius:10px; border:1px solid #303659;
      background:#0f1328; color:#fff; font-size:16px; display:block;
    }
    input::placeholder { color:#8890b3; } input[disabled]{ opacity:.6; }
    button { padding:12px 16px; border-radius:10px; border:1px solid #39406a; background:#2a2f4a; color:#fff; cursor:pointer; transition:.15s transform ease; }
    button:hover { transform: translateY(-1px); } button:disabled { opacity:.55; cursor:not-allowed; transform:none; }

    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hint { font-size:13px; color:#9aa3d7; }
    .ok { color:#69f0ae; } .err { color:#ff6b6b; } .warn { color:#ffd166; }

    .story { background:#0c0f22; border:1px solid #2a2f4a; border-radius:12px; padding:14px; min-height:100px; line-height:1.6; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; }
    .pill { padding:6px 10px; border-radius:999px; background:#1c2142; border:1px solid #2a2f4a; color:#c6cdff; font-size:12px; display:flex; align-items:center; gap:8px; }
    .muted { color:#9aa3d7; font-size:14px; } .spacer{height:10px;} .turn{font-weight:600;} .nameTag{font-weight:700;} .small{font-size:12px;color:#9aa3d7;}
    .divider { height:1px; background:#2a2f4a; margin:14px 0; }
    .tag { display:inline-flex; align-items:center; gap:6px; }
    .dot { width:10px; height:10px; border-radius:50%; background:#666; box-shadow:0 0 0 1px rgba(255,255,255,.12) inset; }

    .word { display:inline; } .word + .word::before { content:" "; }

    .colourWrap { position:relative; display:inline-block; }
    .swatch{ width:28px; height:14px; border-radius:7px; border:1px solid #2a2f4a; background:#58a6ff; display:inline-block; vertical-align:middle; box-shadow: inset 0 0 0 1px rgba(0,0,0,.25); }
    .swatchInput{ position:absolute; inset:0; opacity:0; cursor:pointer; }

    .presence{ font-weight:600; } .online{ color:#69f0ae; } .away{ color:#ffd166; } .offline{ color:#b0b7e1; }

    /* Footer chip (desktop only) */
    .footer-chip{
      position:fixed; bottom:calc(8px + env(safe-area-inset-bottom, 0px)); left:50%; transform:translateX(-50%);
      font-size:12px; color:#9aa3d7; background:rgba(23,26,43,0.92); border:1px solid #2a2f4a; border-radius:10px;
      padding:6px 10px; z-index:30; -webkit-backdrop-filter:saturate(130%) blur(6px); backdrop-filter:saturate(130%) blur(6px);
    }
    @media (max-width: 768px) { .footer-chip { display:none !important; } }

    /* Mobile tweaks */
    @media (max-width: 768px) {
      .row { gap:8px; }
      .pill { font-size:11px; padding:6px 8px; }
      .story { min-height:120px; font-size:16px; }
      #wordInput, #submitBtn { flex:1 1 100%; }
      .toolbar button { flex:1 1 calc(50% - 8px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>
        Story Tag
        <span class="version-label">Alpha <span id="buildVersion" class="version-badge">v0.0.0</span></span>
      </h1>
      <p class="sub">Create a private session with an ID + password, then share both with a friend. Take turns adding one word to build a story.</p>

      <!-- Login -->
      <div id="auth" class="grid">
        <div>
          <label for="name">Your name</label>
          <input id="name" type="text" maxlength="24" placeholder="e.g., Alex" />
        </div>
        <div>
          <label for="sessionId">Session ID</label>
          <input id="sessionId" type="text" maxlength="32" placeholder="e.g., 343w4 (friendly name)" />
          <div class="small hint">This is a friendly label. Privacy comes from the password-derived key.</div>
        </div>
        <div>
          <label for="password">Password</label>
          <input id="password" type="password" maxlength="64" placeholder="Required once unless remembered" />
          <div class="small hint" id="savedHint"></div>
        </div>
        <div class="row">
          <label class="small"><input id="rememberChk" type="checkbox" /> Remember this session on this device</label>
        </div>
        <div class="row">
          <button id="createBtn">Create session</button>
          <button id="joinBtn">Join session</button>
          <div id="joinStatus" class="small"></div>
        </div>
      </div>

      <!-- Game -->
      <div id="game" style="display:none">
        <div class="row">
          <div class="pill">Session: <span id="sessionLabel"></span></div>
          <div class="pill">You:
            <span class="tag">
              <span id="youDot" class="dot"></span>
              <span id="youLabel" class="nameTag"></span>
              <span id="youPresence" class="presence offline">(offline)</span>
            </span>
          </div>
          <div class="pill">Partner:
            <span class="tag">
              <span id="peerDot" class="dot"></span>
              <span id="peerLabel"></span>
              <span id="peerPresence" class="presence offline">(offline)</span>
            </span>
          </div>
          <div class="pill">Words: <span id="wordCount">0</span></div>
          <div class="pill">Status: <span id="statusDot">Waiting…</span></div>
          <div class="pill">
            Colour:
            <span class="colourWrap">
              <span id="colourSwatch" class="swatch" title="Pick your colour"></span>
              <input id="colourPicker" type="color" class="swatchInput" value="#58a6ff" />
            </span>
          </div>
        </div>

        <div class="divider"></div>

        <div class="story" id="storyBox" aria-live="polite">(No words yet—be the first to write!)</div>
        <div class="spacer"></div>

        <div id="turnBanner" class="muted">Waiting for partner…</div>
        <div class="spacer"></div>

        <div class="row">
          <input id="wordInput" type="text" placeholder="Your word…" autocomplete="off" />
          <button id="submitBtn">Add Word</button>
        </div>
        <div class="hint">Rules: one word per turn. Letters, apostrophes, hyphens, and optional punctuation at the end (. , ! ?) allowed.</div>

        <div class="divider"></div>

        <div class="toolbar">
          <button id="copyBtn">Copy story</button>
          <button id="downloadBtn">Download .txt</button>
          <button id="leaveBtn">Leave session</button>
        </div>
        <div id="errorBox" class="small err"></div>
      </div>
    </div>
  </div>

  <!-- Footer (hidden on mobile) -->
  <div class="footer-chip">Built for fun — share your Session ID + Password with a friend and take turns!</div>

  <!-- App -->
  <script type="module">
    /* ========= Version badge from version.json ========= */
    const VERSION_FALLBACK = "v0.0.0";
    (async () => {
      try {
        const res = await fetch(`version.json?ts=${Date.now()}`, { cache: "no-store" });
        const data = await res.json();
        const v = (data && data.version ? data.version : VERSION_FALLBACK);
        document.getElementById("buildVersion").textContent = `v${String(v).replace(/^v/i, "")}`;
      } catch {
        document.getElementById("buildVersion").textContent = VERSION_FALLBACK;
      }
    })();

    /* ========= Firebase ========= */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, get, set, update, onValue, serverTimestamp,
      onDisconnect, remove
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCVOzSTr3lPRm1BRzKTJtdEG-nsdnVIhiM",
      authDomain: "zetabun-91b0c.firebaseapp.com",
      databaseURL: "https://zetabun-91b0c-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "zetabun-91b0c",
      storageBucket: "zetabun-91b0c.firebasestorage.app",
      messagingSenderId: "594713569270",
      appId: "1:594713569270:web:fa1d230bd5fd1ce28549d7",
      measurementId: "G-SQR25FYPLC"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    /* ========= DOM ========= */
    const $ = id => document.getElementById(id);
    const createBtn = $("createBtn"), joinBtn = $("joinBtn"), joinStatus = $("joinStatus"),
          auth = $("auth"), game = $("game"),
          nameInput = $("name"), sessionInput = $("sessionId"), passwordInput = $("password"),
          rememberChk = $("rememberChk"), savedHint = $("savedHint"),
          sessionLabel = $("sessionLabel"),
          youLabel = $("youLabel"), peerLabel = $("peerLabel"),
          youDot = $("youDot"), peerDot = $("peerDot"),
          youPresence = $("youPresence"), peerPresence = $("peerPresence"),
          wordCount = $("wordCount"), statusDot = $("statusDot"),
          storyBox = $("storyBox"), turnBanner = $("turnBanner"),
          wordInput = $("wordInput"), submitBtn = $("submitBtn"),
          colourPicker = $("colourPicker"), colourSwatch = $("colourSwatch"),
          copyBtn = $("copyBtn"), downloadBtn = $("downloadBtn"), leaveBtn = $("leaveBtn"),
          errorBox = $("errorBox");

    /* ========= Stable client id ========= */
    const CID_KEY = "storytag_client_id";
    function getClientId(){ let cid=localStorage.getItem(CID_KEY); if(!cid){ cid="c_"+Math.random().toString(36).slice(2,12); localStorage.setItem(CID_KEY,cid);} return cid; }
    const clientId = getClientId();

    /* ========= Local storage ========= */
    const LS_KEY="storytag_state_v1", REM_KEY="storytag_remembered_sessions_v1", LAST_KEY="storytag_last_session_v1";
    const saveLocal=s=>localStorage.setItem(LS_KEY,JSON.stringify(s));
    const loadLocal=()=>{ try{return JSON.parse(localStorage.getItem(LS_KEY)||"{}");}catch{return{};} };
    const loadRememberMap=()=>{ try{return JSON.parse(localStorage.getItem(REM_KEY)||"{}");}catch{return{};} };
    const saveRememberMap=m=>localStorage.setItem(REM_KEY,JSON.stringify(m));
    const saveLastSession=o=>localStorage.setItem(LAST_KEY,JSON.stringify(o||{}));
    const loadLastSession=()=>{ try{return JSON.parse(localStorage.getItem(LAST_KEY)||"null");}catch{return null;} };

    /* ========= Presence ========= */
    const ONLINE_MS = 20*1000, AWAY_MS = 2*60*1000, STALE_MS = 60*1000;

    function setSavedHintText(sid){ const map=loadRememberMap(); savedHint.textContent=(sid&&map[sid])?"Saved on this device — password optional.":""; }

    /* ========= Helpers ========= */
    const WORD_RX=/^[A-Za-z]+(?:['-][A-Za-z]+)*(?:[.,!?])?$/;
    const titleCaseFirstWordIfNeeded=(i,w)=>(i===0&&w.length)?w[0].toUpperCase()+w.slice(1):w;
    const setUIConnected=b=>statusDot.textContent=b?"Connected":"Offline";
    const escapeHtml=s=>(s||"").replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
    const setDotColour=(el,c,p)=>{ el.style.background=p?(c||"#666"):"#666"; el.style.boxShadow="0 0 0 1px rgba(255,255,255,.12) inset"; };
    const setMyColourUI=hex=>{ if(hex){ colourSwatch.style.background=hex; youDot.style.background=hex; } };
    const presenceOf=ts=>{ const d=Date.now()-(ts||0); return !ts?{cls:"offline",label:"(offline)"}:d<=ONLINE_MS?{cls:"online",label:"(online)"}:d<=AWAY_MS?{cls:"away",label:"(away)"}:{cls:"offline",label:"(offline)"}; };

    async function sha256Base64Url(input){
      const enc=new TextEncoder(); const hash=await crypto.subtle.digest("SHA-256",enc.encode(input));
      const bytes=new Uint8Array(hash); let bin=""; for(let b of bytes) bin+=String.fromCharCode(b);
      return btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,"");
    }

    /* ========= Colour persistence ========= */
    const localColour={}; // uid -> hex

    function renderStory(words, players){
      storyBox.innerHTML=""; if(!words.length){ storyBox.textContent="(No words yet—be the first to write!)"; wordCount.textContent="0"; return; }
      for(const w of words){
        const el=document.createElement("span"); el.className="word";
        const col=w.c || (players?.[w.by]?.colour) || localColour[w.by] || "#c6cdff";
        el.style.color=col; el.textContent=w.w; storyBox.appendChild(el);
      }
      wordCount.textContent=String(words.length);
    }

    function setTurnBanner(currentTurnUid, players, myUid){
      if(!players||!players[myUid]){ turnBanner.textContent="Waiting…"; return; }
      const mine=currentTurnUid===myUid;
      const theirUid=Object.keys(players).find(k=>k!==myUid); const their=theirUid?players[theirUid]:null;
      if(mine) turnBanner.innerHTML=`It’s <span class="turn">your</span> turn to write`;
      else if(their) turnBanner.innerHTML=`<span class="nameTag">${escapeHtml(their?.name||"Partner")}</span>’s turn to write`;
      else turnBanner.textContent="Waiting for partner…";
      submitBtn.disabled=!mine; wordInput.disabled=!mine; if(mine) wordInput.focus();
    }

    // Turn sound
    let audioCtx=null, canPlaySound=false, wasMyTurn=null;
    const ensureAudio=()=>{ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); };
    function playTurnSound(){
      if(!canPlaySound) return;
      try{ ensureAudio(); const now=audioCtx.currentTime;
        const g=audioCtx.createGain(); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.12,now+0.01); g.gain.exponentialRampToValueAtTime(0.0001,now+0.35); g.connect(audioCtx.destination);
        const o=audioCtx.createOscillator(); o.type="sine"; o.frequency.setValueAtTime(660,now); o.frequency.linearRampToValueAtTime(880,now+0.2); o.connect(g); o.start(now); o.stop(now+0.35);
      }catch{}
    }

    // Prefill
    (function(){ const s=loadLocal(); if(s.sessionId&&s.myName){ nameInput.value=s.myName; sessionInput.value=s.sessionId; setSavedHintText(s.sessionId);} })();
    sessionInput.addEventListener("input",()=>setSavedHintText(sessionInput.value.trim()));

    // Join/create with reclaim + stale eviction and NO colour overwrite if seat exists
    async function enterSession(mode, opts={}){
      const {auto=false}=opts; if(!auto) canPlaySound=true;
      joinStatus.textContent=""; const name=(opts.myNameOverride??nameInput.value).trim();
      const sid=(opts.sessionIdOverride??sessionInput.value).trim(); const pwd=opts.passwordOverride ?? passwordInput.value;
      if(!name){ if(!auto) joinStatus.innerHTML='<span class="err">Enter your name</span>'; return; }
      if(!sid){ if(!auto) joinStatus.innerHTML='<span class="err">Enter a session ID</span>'; return; }
      if(!auto){ joinBtn.disabled=true; createBtn.disabled=true; joinStatus.textContent=mode==='create'?'Creating…':'Joining…'; }

      try{
        const remembered=loadRememberMap(); let derivedKey=opts.derivedKeyOverride||null;
        if(!derivedKey){
          if(mode==='join'&&!pwd&&remembered[sid]) derivedKey=remembered[sid];
          else { if(!pwd){ if(!auto) joinStatus.innerHTML='<span class="err">Enter a password</span>'; return; }
                 derivedKey=await sha256Base64Url(`${sid}:${pwd}`); }
        }

        const sesRef=ref(db,`sessions/${derivedKey}`); const snap=await get(sesRef);
        const exists=snap.exists(); const existing=snap.val()||{}; const players=existing.players||{};
        if(mode==='create'&&exists){ if(!auto) joinStatus.innerHTML='<span class="warn">Session already exists. Use Join.</span>'; return; }
        if(mode==='join'&&!exists){ if(!auto) joinStatus.innerHTML='<span class="warn">No session found. Use Create.</span>'; return; }

        // Reclaim or new uid
        let myUid=Object.keys(players).find(u=>players[u]?.clientId===clientId) || ("u_"+Math.random().toString(36).slice(2,10));
        let myName=name;

        // If full and not mine, evict stale (>60s)
        const seatCount=Object.keys(players).length;
        if(seatCount>=2 && !players[myUid]){
          const now=Date.now(); const staleUid=Object.keys(players).find(u=>(now-(players[u]?.lastActive||0))>STALE_MS);
          if(staleUid) await remove(ref(db,`sessions/${derivedKey}/players/${staleUid}`));
          else { if(!auto) joinStatus.innerHTML='<span class="err">Session is full (2/2)</span>'; return; }
        }

        // Create session if needed
        if(!exists&&mode==='create'){ await set(sesRef,{createdAt:serverTimestamp(),friendlyId:sid,words:[],currentTurnUid:myUid,players:{}}); }
        else if(exists&&!existing.friendlyId){ await update(sesRef,{friendlyId:existing.friendlyId||sid}); }

        // Disambiguate names
        if(!players[myUid] && Object.keys(players).length===1){
          const [other]=Object.keys(players);
          if(players[other]?.name?.trim().toLowerCase()===name.toLowerCase()) myName=`${name} (2)`;
        }

        // --- Create/update player seat (DON'T overwrite colour if seat already exists) ---
        const defaultColour= colourPicker.value || `#${Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,"0")}`;
        const myPlayerRef=ref(db,`sessions/${derivedKey}/players/${myUid}`);
        const seatExists = !!players[myUid];

        if (seatExists) {
          await update(myPlayerRef, { uid:myUid, clientId, name:myName, lastActive:Date.now() });
        } else {
          await set(myPlayerRef, { uid:myUid, clientId, name:myName, colour:defaultColour, joinedAt:serverTimestamp(), lastActive:Date.now() });
        }
        onDisconnect(myPlayerRef).remove();
        window.addEventListener("unload",()=>{ try{ navigator.sendBeacon && remove(myPlayerRef); }catch{} });

        // Local remember
        if(!auto&&rememberChk.checked){ const map=loadRememberMap(); map[sid]=derivedKey; saveRememberMap(map); setSavedHintText(sid); }
        saveLastSession({sessionId:sid,derivedKey,myName});

        // UI switch
        auth.style.display="none"; game.style.display="block";
        sessionLabel.textContent=sid; youLabel.textContent=myName;

        // Set local/UI colour from server if present, else default
        const myColourNow = (players[myUid]?.colour) || defaultColour;
        colourPicker.value = myColourNow;
        localColour[myUid] = myColourNow;
        setMyColourUI(myColourNow);

        // Subscribe to session
        if(window._unsub) window._unsub();
        window._unsub=onValue(sesRef,s=>{
          const val=s.val()||{}; const players=val.players||{}; const words=val.words||[]; let cturn=val.currentTurnUid;
          const ids=Object.keys(players); const peerId=ids.find(k=>k!==myUid);

          const meP=presenceOf(players[myUid]?.lastActive); const peP=presenceOf(players[peerId]?.lastActive);
          youPresence.className=`presence ${meP.cls}`; youPresence.textContent=meP.label;
          peerPresence.className=`presence ${peP.cls}`; peerPresence.textContent=peP.label;

          // Find the most recent word by me and use its colour as a fallback
          function lastWordColourBy(uid, wordsArr){
            if (!Array.isArray(wordsArr)) return null;
            for (let i = wordsArr.length - 1; i >= 0; i--) {
              const w = wordsArr[i];
              if (w && w.by === uid && w.c) return w.c;
            }
            return null;
          }

          // Merge colour: prefer server; only fall back to local if server missing
          const mergedPlayers=JSON.parse(JSON.stringify(players||{}));
          const serverColour = players?.[myUid]?.colour || null;
          if (serverColour) {
            // Keep server truth and sync local cache to it
            localColour[myUid] = serverColour;
          } else if (localColour[myUid]) {
            // Use local only when server has nothing yet (e.g., just joined)
            mergedPlayers[myUid] = mergedPlayers[myUid] || {};
            mergedPlayers[myUid].colour = localColour[myUid];
          }
          peerLabel.textContent=peerId?(players[peerId]?.name||"Partner"):"(none)";

          // Sync picker & dots to server colour
          const myEffectiveColour = (players?.[myUid]?.colour) || lastWordColourBy(myUid, words) || localColour[myUid] || colourPicker.value || "#58a6ff";
          if (myEffectiveColour && colourPicker.value.toLowerCase() !== myEffectiveColour.toLowerCase()) {
            colourPicker.value = myEffectiveColour;
          }
          localColour[myUid] = myEffectiveColour;
          setMyColourUI(myEffectiveColour);
          setDotColour(youDot, myEffectiveColour, !!mergedPlayers[myUid]);
          // If server doesn't have my colour yet, persist it once to players/<myUid>
          const serverHasColour = !!(players?.[myUid]?.colour);
          if (!serverHasColour && myEffectiveColour) {
            try { update(ref(db,`sessions/${sidKey||derivedKey}/players/${myUid}`), { colour: myEffectiveColour }); } catch {}
          }


          setDotColour(peerDot, mergedPlayers[peerId]?.colour, !!mergedPlayers[peerId]);


          setUIConnected(ids.length>0);
          renderStory(words,mergedPlayers);

          if(cturn && !players[cturn] && ids.length>0){ const newTurn=ids[0]; update(sesRef,{currentTurnUid:newTurn}); cturn=newTurn; }
          if(ids.length<2 && words.length>0){ submitBtn.disabled=true; wordInput.disabled=true; turnBanner.textContent="Waiting for partner…"; }
          else setTurnBanner(cturn,players,myUid);

          const last=words[words.length-1]; const isMyTurn=(cturn===myUid)&&(ids.length===2);
          if(ids.length===2 && last && last.by===myUid && cturn===myUid && peerId){ update(sesRef,{currentTurnUid:peerId}); }
          if(wasMyTurn===false && isMyTurn) playTurnSound(); wasMyTurn=isMyTurn;

          saveLocal({sessionId:sid,myName});
        });

        if(!auto){ wordInput.focus(); joinStatus.innerHTML='<span class="ok">Ready!</span>'; }

        // Presence heartbeat + on interaction
        if(window._presenceTimer) clearInterval(window._presenceTimer);
        window._presenceTimer=setInterval(()=>{ update(ref(db,`sessions/${derivedKey}/players/${myUid}`), { lastActive: Date.now() }).catch(()=>{}); },10000);
        const bump=()=>update(ref(db,`sessions/${derivedKey}/players/${myUid}`),{ lastActive: Date.now() }).catch(()=>{});
        ["click","keydown","touchstart","visibilitychange"].forEach(ev=>document.addEventListener(ev,bump,{passive:true}));

      }catch(e){
        console.error(e);
        if(!auto) joinStatus.innerHTML='<span class="err">Failed. Check console & Firebase config.</span>';
      }finally{
        if(!auto){ joinBtn.disabled=false; createBtn.disabled=false; }
      }
    }

    createBtn.onclick=()=>enterSession('create');
    joinBtn.onclick=()=>enterSession('join');

    /* ========= Colour change: update UI instantly, then DB ========= */
    async function handleColourChange(){
      try{
        const last=loadLastSession(); if(!last) return;
        const sesRef=ref(db,`sessions/${last.derivedKey}`); const snap=await get(sesRef);
        const players=(snap.val()&&snap.val().players)||{}; const myUid=Object.keys(players).find(u=>players[u]?.clientId===clientId);
        const hex=colourPicker.value;

        // Instant UI
        localColour[myUid]=hex; setMyColourUI(hex); setDotColour(youDot,hex,true);

        // Persist
        if(myUid) await update(ref(db,`sessions/${last.derivedKey}/players/${myUid}`),{ colour:hex, lastActive:Date.now() });
      }catch(e){ console.error(e); }
    }
    colourPicker.addEventListener("input",handleColourChange);
    colourPicker.addEventListener("change",handleColourChange);

    /* ========= Submit word ========= */
    submitBtn.onclick=async ()=>{
      errorBox.textContent="";
      let word=(wordInput.value||"").trim(); if(!word) return;

      const last=loadLastSession(); if(!last){ errorBox.textContent="No active session."; return; }
      const sesRef=ref(db,`sessions/${last.derivedKey}`); const sesSnap=await get(sesRef); const ses=sesSnap.val();
      if(!ses){ errorBox.textContent="Session not found."; return; }

      const players=ses.players||{}; const myUid=Object.keys(players).find(u=>players[u]?.clientId===clientId);
      if(!myUid){ errorBox.textContent="Rejoin required."; return; }
      if(ses.currentTurnUid!==myUid){ errorBox.textContent="Not your turn yet."; wordInput.value=""; return; }
      if(!WORD_RX.test(word)){ errorBox.textContent="Invalid word. Use letters, apostrophes, hyphens, optional .,!? at end."; return; }

      const words=Array.isArray(ses.words)?ses.words:[]; const peerUid=Object.keys(players).find(k=>k!==myUid);
      const myColourNow=(players[myUid]?.colour)||localColour[myUid]||colourPicker.value||"#c6cdff";

      try{
        await update(sesRef,{
          words:[...words,{ w:titleCaseFirstWordIfNeeded(words.length,word), by:myUid, c:myColourNow, t:Date.now() }],
          currentTurnUid: peerUid || myUid
        });
        wordInput.value="";
        if(!peerUid){ submitBtn.disabled=true; wordInput.disabled=true; turnBanner.textContent="Waiting for partner…"; }
        await update(ref(db,`sessions/${last.derivedKey}/players/${myUid}`),{lastActive:Date.now()});
      }catch(e){ console.error(e); errorBox.textContent="Failed to add word. Check your connection."; }
    };

    /* ========= Utilities ========= */
    copyBtn.onclick=async()=>{ const txt=[...document.querySelectorAll("#storyBox .word")].map(el=>el.textContent).join(" "); await navigator.clipboard.writeText(txt); copyBtn.textContent="Copied!"; setTimeout(()=>copyBtn.textContent="Copy story",1200); };
    downloadBtn.onclick=()=>{ const last=loadLastSession(); const fileSid=last?.sessionId||"session"; const txt=[...document.querySelectorAll("#storyBox .word")].map(el=>el.textContent).join(" "); const blob=new Blob([txt],{type:"text/plain"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=`story-${fileSid}.txt`; a.click(); URL.revokeObjectURL(a.href); };
    leaveBtn.onclick=async()=>{ try{ const last=loadLastSession(); if(last){ const sesRef=ref(db,`sessions/${last.derivedKey}`); const snap=await get(sesRef); const players=(snap.val()&&snap.val().players)||{}; const myUid=Object.keys(players).find(u=>players[u]?.clientId===clientId); if(myUid) await remove(ref(db,`sessions/${last.derivedKey}/players/${myUid}`)); } }catch{} localStorage.removeItem(LAST_KEY); location.reload(); };

    wordInput.addEventListener("keydown",e=>{ if(e.key==="Enter") submitBtn.click(); });
    sessionInput.addEventListener("keydown",e=>{ if(e.key==="Enter") joinBtn.click(); });
    passwordInput.addEventListener("keydown",e=>{ if(e.key==="Enter") joinBtn.click(); });

    document.addEventListener("visibilitychange",()=>{ statusDot.textContent=document.hidden?"Background":"Connected"; });

    // Auto-resume
    (async function(){
      const last=loadLastSession(); if(!last) return;
      if(last.sessionId) sessionInput.value=last.sessionId;
      if(last.myName) nameInput.value=last.myName;
      setSavedHintText(last.sessionId||"");
      await enterSession('join',{ auto:true, sessionIdOverride:last.sessionId||"", myNameOverride:last.myName||"", derivedKeyOverride:last.derivedKey||null });
    })();
  </script>

  <!-- Reduce accidental zooms -->
  <script>
    document.documentElement.style.touchAction = 'manipulation';
    ['gesturestart','gesturechange','gestureend'].forEach(evt=>{
      window.addEventListener(evt, e=>{ e.preventDefault(); }, { passive:false });
    });
  </script>
</body>
</html>